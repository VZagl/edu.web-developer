# 021. Специфичность CSS селекторов

> Селекторы также изучались в уроках:
>
> - `014. Основы CSS на практике`

---

## Основные виды селекторов

Основных видов селекторов всего несколько:

- `*` – любые элементы.
- `div` – элементы с таким тегом.
- `#id` – элемент с данным `id`.
- `.class` – элементы с таким классом.
- `[name="value"]` – селекторы на атрибут (см. далее).
- `:visited` – «псевдоклассы», остальные разные условия на элемент (см. далее).

Селекторы можно комбинировать, записывая последовательно, без пробела:

- `.c1.c2` – элементы одновременно с двумя классами `c1` и `c2`
- `a#id.c1.c2:visited` – элемент `a` с данным `id`, классами `c1` и `c2`, и псевдоклассом `visited`

## Отношения

В CSS3 предусмотрено четыре вида отношений между элементами.

Самые известные вы наверняка знаете:

- `div p` – элементы p, являющиеся потомками `div`.
- `div > p` – только непосредственные потомки.

Есть и два более редких:

- `div ~ p` – правые соседи: все p на том же уровне вложенности, которые идут после `div`.
- `div + p` – первый правый сосед: `p` на том же уровне вложенности, который идёт сразу после `div` (если есть).

## Фильтр по месту среди соседей

При выборе элемента можно указать его место среди соседей.

Список псевдоклассов для этого:

- `:first-child` – первый потомок своего родителя.
- `:last-child` – последний потомок своего родителя.
- `:only-child` – единственный потомок своего родителя, соседних элементов нет.
- `:nth-child(a)` – потомок номер `a` своего родителя, например `:nth-child(2)` – второй потомок. Нумерация начинается с `1`.
- `:nth-child(an+b)` – расширение предыдущего селектора через указание номера потомка формулой, где `a,b` – константы, а под `n` подразумевается любое целое число.

  Этот псевдокласс будет фильтровать все элементы, которые попадают под формулу при каком-либо `n`. Например:

  - `:nth-child(2n)` даст элементы номер `2`, `4`, `6`…, то есть чётные.
  - `:nth-child(2n+1)` даст элементы номер `1`, `3`…, то есть нечётные.
  - `:nth-child(3n+2)` даст элементы номер `2`, `5`, `8` и так далее.

## Фильтр по месту среди соседей с тем же тегом

Есть аналогичные псевдоклассы, которые учитывают не всех соседей, а только с тем же тегом:

- `:first-of-type`
- `:last-of-type`
- `:only-of-type`
- `:nth-of-type`
- `:nth-last-of-type`

Они имеют в точности тот же смысл, что и обычные `:first-child`, `:last-child` и так далее, но во время подсчёта игнорируют элементы с другими тегами, чем тот, к которому применяется фильтр.

## Селекторы атрибутов

На атрибут целиком:

- `[attr]` – атрибут установлен,
- `[attr="val"]` – атрибут равен `val`.

На начало атрибута:

- `[attr^="val"]` – атрибут начинается с `val`, например `"value"`.
- `[attr|="val"]` – атрибут равен `val` или начинается с `val-`, например равен `"val-1"`.

На содержание:

- `[attr*="val"]` – атрибут содержит подстроку `val`, например равен `"myvalue"`.
- `[attr~="val"]` – атрибут содержит `val` как одно из значений через пробел.

Например: `[attr~="delete"]` верно для `"edit delete"` и неверно для `"undelete"` или `"no-delete"`.

На конец атрибута:

- `[attr$="val"]` – атрибут заканчивается на `val`, например равен `"myval"`.

## Другие псевдоклассы

- `:not(селектор)` – все, кроме подходящих под селектор.
- `:focus` – в фокусе.
- `:hover` – под мышью.
- `:empty` – без детей (даже без текстовых).
- `:checked`, `:disabled`, `:enabled` – состояния `INPUT`.
- `:target` – этот фильтр сработает для элемента, `ID` которого совпадает с анкором `#...` текущего URL.

Например, если на странице есть элемент с `id="intro"`, то правило - `:target { color: red }` подсветит его в том случае, если текущий URL имеет вид `http://...#intro`.

## Псевдоэлементы `::before`, `::after`

«Псевдоэлементы» – различные вспомогательные элементы, которые браузер записывает или может записать в документ.

При помощи псевдоэлементов `::before` и `::after` можно добавлять содержимое в начало и конец элемента:

```html
<style>
	li::before {
		content: ' [[ ';
	}

	li::after {
		content: ' ]] ';
	}
</style>

Обратите внимание: содержимое добавляется <b>внутрь</b> LI.

<ul>
	<li>Первый элемент</li>
	<li>Второй элемент</li>
</ul>
```

Результат будет:

> Обратите внимание: содержимое добавляется <b>внутрь</b> LI.
>
> <ul>
>   <li>[[ Первый элемент ]]</li>
>   <li>[[ Второй элемент ]]</li>
> </ul>

Псевдоэлементы `::before`/`::after` добавили содержимое в начало и конец каждого `LI`.

---

## CSS: Приоритет стилей

Говоря о каскадности, возникает вопрос: «А что произойдёт, если в разных источниках будут одинаковые правила для элемента, но с разными значениями?». В таком случае есть правила, определяющие приоритеты стилей из разных источников. По степени важности список выглядит следующим образом:

1. Стили в атрибуте тега
2. Стили в отдельном файле
3. Стили по умолчанию, которые добавляет браузер

Значения, указанные в атрибуте `style` будут важнее свойств в теге `<style>`, а они будут важнее стандартных стилей браузера.

## Приоритеты селекторов

Важной чертой CSS является то, что разные типы селекторов имеют разный приоритет. Если стили противоречат друг другу в разных селекторах, то вступает в дело принцип приоритета.

У селекторов также существуют приоритеты. Условно можно расставить селекторы в следующем порядке по приоритету:

1. Селектор по идентификатору (`#blue`)
2. Селектор по классу (`.red`)
3. Селектор по тегу (`p`)

Где 1 — самый высокий приоритет, а 3 — самый низкий.

По этим правилам можно понять, что свойства указанные в селекторе по идентификатору будет обладать большим приоритетом, чем стили у селектора по тегу и классу.

Это легко запомнить, если селекторы небольшие, но они могут быть сложнее. В качестве селектора может быть комбинация классов, тегов и так далее. Например:

```html
<style>
	.paragraph {
		color: red;
	}

	.paragraph.color-primary {
		color: blue;
	}
</style>

<p class="paragraph color-primary">Параграф</p>
<p class="paragraph">Параграф</p>
<p class="paragraph color-primary">Параграф</p>
```

В этом примере все параграфы с классом `paragraph` будут иметь красный цвет текста, но если дополнительно установлен класс `color-primary`, то цвет будет голубой. Почему так происходит? У таких селекторов также есть свои приоритеты. В сложных селекторах считается количество вхождений тех или иных селекторов и считается суммарный вес.

Для определения приоритета можно использовать следующие правила, где каждому селектору задаётся его «вес»:

- Селектор по тегу: `1`
- Селектор по классу: `10`
- Селектор по ID: `100`
- Стиль в атрибуте тега: `1000`

Чтобы узнать, какой селектор будет иметь больший вес, нужно сложить все полученные значения. Например:

- Селектор `.paragraph` состоит из одного класса, а значит его вес — `10`
- Селектор `.paragraph.color-primary` состоит из двух классов. Его вес — `20`

Таким образом свойства у селектора `.paragraph.color-primary` будут иметь больший приоритет, чем внутри селектора `.paragraph`.

Если используются несколько классов, то применится стиль того класса, который находится последним в файле слилей. Например:

```html
<style>
	.red {
		color: red;
	}

	.green {
		color: green;
	}
</style>

<p class="red green">Параграф</p>
<p class="green red">Параграф</p>
```

В результате получим <span style="color:green">зелёный</span> цвет для обоих параграфов.

---

## Ресурсы:

- [Формула расчета](https://code-basics.com/ru/languages/css/lessons/priority)
- ["Знаете ли вы селекторы?"](https://learn.javascript.ru/css-selectors)
